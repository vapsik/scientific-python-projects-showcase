Ahoi, füüsikud!

Seoses selle aeroautopraksiga siis, kuna mul oli veits igav, siis ma otsustasin seda mudelit täiustada, lisades Newtoni II seaduse diferentsiaalvõrrandisse juurde liikme F_õhutakistus = -bv - cv^2 (õhutakistus on võrdeline kiiruse (laminaarne) ja kiiruse ruudu (turbulentne) skaleeritud summadega (b1  b2 ja c1  c2 olgu need tegurid vastavalt (1 või 2, sõltuvalt, kas auto sõidab tagurpidi või edaspidi (ehk kokku tuleb 6 parameetrit (5x nested sulud, lol))))). Kuna see DV ei lahendu analüütiliselt (või kui lahendub, siis tükiti ja väga vaevaliselt), siis inspireerituna masinõppe kontseptsioonist nimega kaofunktsioon (loss function), koostasin funktsiooni, mis võtab sisendiks optimeeritavad parameetrid, arvutab difvõrrandi numbrilise lahendi mõõdetud algtingimustega üle kõigi ajaliste sõlmpunktide ning väljastab ruutnormi mõõdetud andmete (kiirused ja asukohad) ja selle DV numbrilise lahendi vahel, nii et seda minimeerides saamegi kõige optimaalsemad ja täpsemad parameetrid, mis peaksid andma mõõtmistega klappivad graafikud. DV lahendamiseks kasutasin diferentsiaalvõrrandite numbrilist lahendajat scipy.integrate.solve_ivp-d (vaikimisi kasutab Runge-Kutta 45 meetodit). Minimeerimiseks kasutasin pythoni käsklust scipy.optimize.minimize (method = Nelder-Mead). Sain suhteliselt head tulemused - selle mudeli mõõdetud veokiirendusest arvutatud jõud ühtib nii jõu mõõtmiste tulemustega kui ka parabooli fittimise mudeli tulemusega ( 0.145N ümbruses).

Probleem on lihtsalt selles, et kuigi on tegu keskeltläbi hea mudeliga, on see ilmselt siiski veidike pseudoteaduslik fittimine, kuna see on väga tundlik parameetrite algpakkumise suhtes ning ühest koonduvust õhutakistuse parameetrite puhul näiteks ei tekkinud erinevate algpakkumiste suhtes, ilmselt toimusid hüpped ühest lokaalsest miinimumist teise lihtsalt. Seega, kui viitsite, checkige mu koodi ja rakendage seda oma Vernier' datal. (vaja ka kiiruse datat, kiiruse andmevektori võib ka ise sünteetiliselt tekitada numpy.gradienti rakendades, sest see on praktiliselt sama, mida Vernier kiiruse dataks teeb - jagab viimase kahe kauguse vahe ajaliste sõlmpunktide vahega). Ja kui katsetate, siis andke mulle teada, milliste parameetrite algpakkumiste puhul minimeerimisel kaofunktsiooni minimaalseimaks väärtuseks saate (hetkel on mul rekord 0.00168, äkki koos leiame globaalse miinimumi lol). 

Katseandmete failid on saadaval samas Githubi kaustas, seega võite sama malli kasutades oma Vernier' data sinna asemele toppida.
